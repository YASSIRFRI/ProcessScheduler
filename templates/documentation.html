<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Documentation</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <style>
        /* Custom styles */
        body {
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .navbar {
            background-color: #343a40 !important;
        }
        .navbar-light .navbar-nav .nav-link {
            color: #f8f9fa !important;
        }
        .footer {
            background-color: #343a40;
            color: #f8f9fa;
            margin-top: auto;
            width: 100%;
        }
        .documentation-content, .algorithm-content {
            margin-top: 20px;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 16px;
        }
        .references-content {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 20px;
            background-color: #343a40;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            color: #f8f9fa;
        }
        .title-light {
            color: #f8f9fa;
        }
    </style>
</head>
<body>
    <header>
        <nav class="navbar navbar-expand-lg navbar-dark bg-dark">
            <div class="container">
                <a class="navbar-brand title-light" href="/">Process Scheduling Algorithm</a>
                <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
    
                <div class="collapse navbar-collapse" id="navbarSupportedContent">
                    <ul class="navbar-nav ml-auto">
                        <li class="nav-item">
                            <a class="nav-link" href="/file">File upload</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="/manual">Manual Upload</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="/generate">Randomly Generate</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="/compare">Compare Algorithms</a>
                        </li>
                        <li class="nav-item">
                            <a class="nav-link" href="/documentation">Documentation</a>
                        </li>
                    </ul>
                </div>
            </div>
        </nav>
    </header>

    <div class="container documentation-content">
        <h2>How to Use the Process Scheduling App</h2><hr>
        <p>Welcome to the documentation page of the Process Scheduling Algorithm app. This app is created by Yassir and Zakaria for our first operating systems assignment. Here's a guide on how to use it:</p>
        <ol>
            <li><strong>File Upload:</strong> Navigate to the "File upload" section to submit a CSV file containing process data. Each line of the CSV should be in one of the following two forms:
                <ul>
                    <li>process_id,arrival_time,burst_time</li>
                    <li>process_id,arrival_time,burst_time,priority (for priority-based algorithms)</li>
                </ul>
                After uploading the file, choose one of the five available scheduling algorithms: First Come First Served (FCFS), Shortest Job First (SJF), Priority Scheduling, Round Robin, or Priority with Round Robin. If you choose Round Robin or Priority with Round Robin, you'll need to specify the time quantum.</li>
            <li><strong>Manual Upload:</strong> If you prefer, you can manually enter process data in the "Manual Upload" section. Enter information regarding processes (process_id, arrival_time, burst_time) manually. To add a process, click on the "Add Process" button. Once you have entered all the required process information and selected your algorithm, click the "Submit" button to process the data.</li>
            <li><strong>Randomly Generate:</strong> Use the "Randomly Generate" section to create random process data for testing purposes. Specify the number of random processes to be generated, then click the "Generate Processes" button. After generating the processes, choose your algorithm and press the "Submit" button to process the data.</li>
            <li><strong>Compare Algorithms:</strong> Visit the "Compare Algorithms" section to compare different process scheduling algorithms.</li>
            <li><strong>Documentation:</strong> Takes you to this page where you can read how to use the app.</li>
        </ol>
    </div>

    <div class="container algorithm-content">
        <h2>Algorithm Description and Complexity Analysis</h2><hr>
        <h3>First Come First Served (FCFS)</h3>
        <p>FCFS is the simplest scheduling algorithm, where processes are executed in the order they arrive in the ready queue. It is non-preemptive, meaning once a process starts execution, it continues until completion.</p>
        <p><strong>Complexity:</strong> The complexity of FCFS is <strong>O(n)</strong> if the processes are provided in the order of their arrival time.
            However because we sort the processes based on their arrival time, an additional <strong>O(nlogn)</strong> is added to the complexity.
            The complexity of FCFS is <strong>O(nlogn)</strong> in the worst case.
        </p>
        <h3>Shortest Job First (SJF)</h3>
        <p>SJF selects the process with the shortest burst time to execute next. It can be either preemptive or non-preemptive. In preemptive SJF, if a new process arrives with a shorter burst time than the currently running process, the CPU switches to the new process.</p>
        <p><strong>Complexity:</strong> 
            Our implementation of SJF has a complexity of <strong>O(nlogn)</strong> because we sort the processes based on their burst time. If the processes are already sorted based on their burst time, the complexity is <strong>O(n)</strong>.

        </p>
    
        <h3>Priority Scheduling</h3>
        <p>In Priority Scheduling, each process is assigned a priority, and the process with the smallest priority number priority is executed first. If two processes have the same priority, FCFS is used as a tie-breaker.</p>
        <p><strong>Complexity:</strong> The complexity of Priority Scheduling is similar to SJF so our naive implementation has a complexity of <strong>O(n^2)</strong>,
             . If implemented using a priority queue, the complexity is O(n log n).</p>
        <h3>Round Robin</h3>
        <p>Round Robin is a preemptive scheduling algorithm where each process is assigned a fixed time slice (quantum) to execute. Once a process consumes its time slice, it is moved to the back of the ready queue, and the next process in line is given CPU time.</p>
        <p><strong>Complexity:</strong> The complexity of Round Robin is <strong>O(n*(MaxBurstTime/quantum)+nlog)</strong>, assuming processes are not sorted by arrival time for a time slice of 1, but it improves to O(n) for larger time quantum.
            However the because we perform a sort on the processes based on their arrival time, an additional O(nlogn) is added to the complexity.
        </p>
        <h3>Priority with Round Robin</h3>
        <p>Priority with Round Robin is a combination of Priority Scheduling and Round Robin. Processes are scheduled based on their priority, and if two processes have the same priority, Round Robin scheduling is used.</p>
        <p><strong>Complexity:</strong> The Worst Case time complexity of our implementation, is <strong>O(n*(MaxBurstTime/quantum)+nlogn)</strong> which
        which scales well given the expected number of processses that we input, however the complexity could be brought down to  O(nlogn) using a priority queue again.</p>
    </div>
    <div class="container references-content mt-5">
        <h2>References</h2>
        <ul>
            <li><a href="https://flask.palletsprojects.com/en/2.0.x/">Flask Documentation</a></li>
            <li><a href="https://plotly.com/python/">Plotly Documentation</a></li>
            <li><a href="https://dash.plotly.com/">Dash Documentation</a></li>
        </ul>
    </div>
    <footer class="footer">
        <div class="container text-center">
            <span>Â© 2024 Process Scheduling Algorithms</span>
        </div>
    </footer>
    <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.5.4/dist/umd/popper.min.js"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>
</body>
</html>
